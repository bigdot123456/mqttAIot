package main

import (
	"fmt"
	"github.com/bwmarrin/snowflake"
	"github.com/fsnotify/fsnotify"
	"syscall"

	"github.com/google/uuid"
	"github.com/jeek120/cpuid"
	//"github.com/satori/go.uuid"
	"github.com/spf13/viper"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"os"
)

type AutoGenerated struct {
	Title  string `toml:"title"`
	Server struct {
		IP            string `toml:"IP"`
		Port          int    `toml:"port"`
		ConnectionMax int    `toml:"connection_max"`
	} `toml:"server"`
	Client struct {
		Username string `toml:"username"`
		Passwd   string `toml:"passwd"`
		Topic    string `toml:"topic"`
	} `toml:"client"`
	Mysql struct {
		IP     string `toml:"ip"`
		Port   int    `toml:"port"`
		Name   string `toml:"name"`
		Passwd string `toml:"passwd"`
	} `toml:"mysql"`
}

func init() {
	path, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	viper.AddConfigPath(path + "/config")
	viper.SetConfigName("config") //指定配置文件的文件名称(不需要制定配置文件的扩展名)
	//viper.AddConfigPath("/etc/appname/")   //设置配置文件的搜索目录
	//viper.AddConfigPath("$HOME/.appname")  // 设置配置文件的搜索目录
	viper.AddConfigPath(".")   // 设置配置文件和可执行二进制文件在用一个目录
	err = viper.ReadInConfig() // 根据以上配置读取加载配置文件
	if err != nil {
		log.Fatal(err) // 读取配置文件失败致命错误
	}
	viper.WatchConfig()
	viper.OnConfigChange(func(e fsnotify.Event) {
		//viper配置发生变化了 执行响应的操作
		fmt.Println("Config file changed:", e.Name)
	})
	viper.SetDefault("Server.IP", "127.0.0.1")
	viper.SetDefault("Server.port", 1883)
	viper.SetDefault("LayoutDir", "layouts")
	viper.SetDefault("Taxonomies", map[string]string{"tag": "tags", "category": "categories"})
}

func getCPUIDStr() string {
	ids := [4]uint32{}
	cpuid.Cpuid(&ids, 0)
	//fmt.Printf("%d%d%d%d", ids[0], ids[1], ids[2], ids[3])
	cpustr := fmt.Sprintf("%d%d%d%d", ids[0], ids[1], ids[2], ids[3])
	return cpustr
}

func get_external() string {
	resp, err := http.Get("http://myexternalip.com/raw")

	if err != nil {
		os.Stderr.WriteString(err.Error())
		os.Stderr.WriteString("\n")
		//os.Exit(1)
		return ""
	}
	defer resp.Body.Close()
	//io.Copy(os.Stdout, resp.Body)
	//os.Exit(0)
	s0, err := ioutil.ReadAll(resp.Body)
	s := string(s0)
	return s
}

func get_internal() string {
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		os.Stderr.WriteString("Oops:" + err.Error())
		return ""
	}
	s := ""
	for _, a := range addrs {
		if ipnet, ok := a.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
			if ipnet.IP.To4() != nil {
				s += ipnet.IP.String() + "\n"
			}
		}
	}
	//os.Stdout.WriteString(s)
	return s
}
func getMACID() string {
	interfaces, err := net.Interfaces()
	if err != nil {
		panic("MACID FAIL: " + err.Error())
	}
	s := ""
	for _, inter := range interfaces {
		//fmt.Println(inter.Name, inter.HardwareAddr)
		s += fmt.Sprintf("Name:\t%s  Address:\t%s\n", inter.Name, inter.HardwareAddr)
	}
	return s
}
func getDiskID() string {

	var st syscall.Stat_t
	err := syscall.Stat("/dev/disk0", &st)
	if err != nil {
		panic(err)
	}
	return fmt.Sprintf("%+v", st)
}

//import "github.com/satori/go.uuid"

func getUUID(NodeID int64) string {
	node, err := snowflake.NewNode(NodeID)
	if err != nil {
		fmt.Println(err)
		u1 := uuid.Must(uuid.New(), nil).String()
		//fmt.Printf("UUID: %s", u1)
		return u1
	}
	id := node.Generate().String()
	//fmt.Println("id is:", id)

	return id
}
